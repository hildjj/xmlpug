// Generated by CoffeeScript 1.10.0
(function() {
  var DEFAULT_CONFIG, bb, cache, compilePug, dentToString, error, fix, fs, parseXml, path, pkg, pug, req, resolve, transform, transformFile, xml;

  try {
    require('source-map-support').install();
  } catch (error) {

  }

  bb = require('bluebird');

  fs = bb.promisifyAll(require('fs'));

  dentToString = require('dentin').dentToString;

  xml = require('libxmljs');

  pug = require('pug');

  pkg = require('../package');

  path = require('path');

  resolve = require('resolve');

  cache = require('./cache');

  req = require;

  DEFAULT_CONFIG = "./.xmlpug.json";

  fix = function(r) {
    var t;
    if (r == null) {
      return r;
    } else {
      t = typeof r;
      if (t === 'string' || t === 'number') {
        return r;
      } else {
        switch (r.type()) {
          case 'attribute':
            return r.value();
          case 'text':
            return r.text();
          default:
            return r;
        }
      }
    }
  };

  compilePug = function(pugdata, options) {
    if (options == null) {
      options = {};
    }
    if (typeof pugdata === 'function') {
      return bb.resolve(pugdata);
    }
    return bb["try"](function() {
      var fn;
      if (options.xmlpugSource) {
        fn = pug.compileClient(pugdata, options);
        return fs.writeFileAsync(options.xmlpugSource, fn.toString());
      }
    }).then(function() {
      return pug.compile(pugdata, options);
    });
  };

  parseXml = function(xmldata) {
    var e, er, i, len1, ref, xmldoc;
    xmldoc = xml.parseXmlString(xmldata, {
      noent: true
    });
    if ((xmldoc != null ? xmldoc.errors.length : void 0) > 0) {
      er = "XML Error (input XML " + e.line + ":" + e.column + "):\n";
      ref = xmldoc.errors;
      for (i = 0, len1 = ref.length; i < len1; i++) {
        e = ref[i];
        e += "  " + e.message + "\n";
      }
      throw new Error(e);
    }
    return xmldoc;
  };

  this.transform = transform = function(pugdata, xmldata, options) {
    var pretty;
    if (options == null) {
      options = {
        pretty: true
      };
    }
    pretty = options.pretty;
    options.pretty = false;
    return compilePug(pugdata, options).then(function(pugFunc) {
      var dopts, found, k, out, v, xmldoc;
      if (xmldata instanceof xml.Document) {
        xmldoc = xmldata;
        xmldata = xmldoc.toString();
      } else {
        xmldoc = parseXml(xmldata);
      }
      out = pugFunc({
        defs: options.define,
        $: function(q, c, ns) {
          if (q == null) {
            q = '.';
          }
          if (c == null) {
            c = xmldoc;
          }
          if ((c != null) && (ns == null) && (!(c instanceof xml.Document)) && (!(c instanceof xml.Element))) {
            ns = c;
            c = xmldoc;
          }
          return fix(c.get(q, ns));
        },
        $$: function(q, c, ns) {
          var i, len1, r, ref, results;
          if (q == null) {
            q = '.';
          }
          if (c == null) {
            c = xmldoc;
          }
          if ((c != null) && (ns == null) && (!(c instanceof xml.Document)) && (!(c instanceof xml.Element))) {
            ns = c;
            c = xmldoc;
          }
          ref = c.find(q, ns);
          results = [];
          for (i = 0, len1 = ref.length; i < len1; i++) {
            r = ref[i];
            results.push(fix(r));
          }
          return results;
        },
        $att: function(e, a) {
          var all, at, i, len1, n, ns, ref, ref1, v;
          if (e == null) {
            return null;
          } else if ((a == null) || (typeof a === 'object')) {
            all = {};
            ref = e.attrs();
            for (i = 0, len1 = ref.length; i < len1; i++) {
              at = ref[i];
              v = at.value();
              if (v != null) {
                n = at.name();
                ns = at.namespace();
                if ((ns != null) && (ns.prefix() != null)) {
                  n = ns.prefix() + ':' + n;
                }
                all[n] = v;
              }
            }
            if (a != null) {
              for (n in a) {
                v = a[n];
                if (v != null) {
                  all[n] = v;
                }
              }
            }
            return all;
          } else {
            return (ref1 = e.attr(a)) != null ? ref1.value() : void 0;
          }
        },
        $element: function(name, content) {
          return new xml.Element(xmldoc, name, content);
        },
        $nsDecls: function(e, a) {
          var i, len1, n, ns, p, ref, res, v;
          e = e || xmldoc.root();
          res = {};
          ref = e.namespaces(true);
          for (i = 0, len1 = ref.length; i < len1; i++) {
            ns = ref[i];
            n = 'xmlns';
            p = ns.prefix();
            if (p != null) {
              n += ':' + p;
            }
            res[n] = ns.href();
          }
          if (a != null) {
            for (n in a) {
              v = a[n];
              if (v != null) {
                res[n] = v;
              }
            }
          }
          return res;
        },
        $qname: function(e) {
          var ns;
          ns = e.namespace();
          if ((ns != null) && (ns.prefix() != null)) {
            return ns.prefix() + ":" + e.name();
          } else {
            return e.name();
          }
        },
        $root: function() {
          return xmldoc.root();
        },
        $source: xmldata,
        $sourceFile: options.xmlFileName,
        require: function(mod) {
          var dn, fileName;
          dn = options.pugFileName ? path.dirname(options.pugFileName) : __dirname;
          fileName = resolve.sync(mod, {
            basedir: dn
          });
          return req(fileName);
        },
        version: pkg.name + " v" + pkg.version
      });
      if (pretty) {
        dopts = {};
        for (k in options) {
          v = options[k];
          found = false;
          k = k.replace(/^dentin-/, function() {
            found = true;
            return "";
          });
          if (found) {
            dopts[k] = v;
          }
        }
        if (dopts.html == null) {
          dopts.html = options.html;
        }
        out = dentToString(out, dopts);
      }
      return out;
    });
  };

  this.transformFile = transformFile = function(pugFileName, xml, options) {
    if (options == null) {
      options = {
        pretty: true
      };
    }
    if (options.pugFileName == null) {
      options.pugFileName = pugFileName;
    }
    options.filename = options.pugFileName;
    return bb.all([
      cache.read(pugFileName, function(pugdata) {
        return compilePug(pugdata, options);
      }), (function() {
        switch (false) {
          case xml !== null:
            return null;
          case !Buffer.isBuffer(xml):
            if (options.xmlFileName == null) {
              options.xmlFileName = 'Buffer';
            }
            return xml;
          default:
            if (xml === '-') {
              xml = '/dev/stdin';
            }
            options.xmlFileName = xml;
            return cache.read(xml);
        }
      })()
    ]).then(function(arg) {
      var pugFunc, xmlData;
      pugFunc = arg[0], xmlData = arg[1];
      if (xmlData) {
        return transform(pugFunc, xmlData, options);
      }
    });
  };

  this.read_config = function(opts) {
    var ref;
    if (opts == null) {
      opts = {};
    }
    return fs.readFileAsync((ref = opts.config) != null ? ref : DEFAULT_CONFIG).then(function(data) {
      return Object.assign(opts, JSON.parse(data));
    }).catchReturn(opts);
  };

  this.cmd = function(args) {
    var commander, define, defs, len, opts, program;
    defs = {};
    define = function(v) {
      var m;
      m = v.match(/([^=]+)\s*=\s*(.*)/);
      if (!m) {
        return console.error("Invalid definition: '" + v + "'");
      } else {
        return defs[m[1]] = m[2];
      }
    };
    commander = require('commander');
    program = new commander.Command;
    program.version(pkg.version).usage('[options] <template> [input]').option('-c, --config <file>', "Config file to read [" + DEFAULT_CONFIG + "]", DEFAULT_CONFIG).option('-d, --debug', 'Add Pug debug information').option('-D, --define [name=string]', 'Define a global variable', define).option('--doublequote', 'Use doublequotes instead of single').option('-o, --output [file]', 'Output file').option('-p, --pretty', 'Pretty print').option('--html', 'HTML output; only useful for pretty printing').option('-s, --source [file]', 'Output source for client transformation').parse(args);
    len = program.args.len;
    if (((program.source != null) && (len < 1)) || (len < 2)) {
      program.help();
    }
    if (program.args.length < 1) {
      program.help();
    }
    opts = {
      pretty: program.pretty,
      compileDebug: program.debug,
      xmlpugSource: program.source,
      config: program.config,
      html: false,
      "dentin-doublequote": program.doublequote
    };
    if (program.html || ((program.output != null) && program.output.match(/\.html?$/))) {
      opts.html = true;
    }
    return this.read_config(opts).then(function(opts) {
      if (opts.define != null) {
        opts.define = Object.assign(defs, opts.define);
      } else {
        opts.define = defs;
      }
      return transformFile(program.args[0], program.args[1], opts);
    }).then(function(output) {
      if (output == null) {
        return;
      }
      if (program.output != null) {
        return fs.writeFileAsync(program.output, output).thenReturn(output);
      } else {
        console.log(output);
        return output;
      }
    });
  };

}).call(this);

//# sourceMappingURL=index.js.map
